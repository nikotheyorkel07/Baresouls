import React, { useState, useEffect, useRef } from "react";
import { base44 } from "@/api/base44Client";
import { useQuery, useQueryClient } from "@tanstack/react-query";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";
import { Button } from "@/components/ui/button";
import { Users, Loader2, Sparkles } from "lucide-react";
import { useNavigate } from "react-router-dom";
import { createPageUrl } from "@/utils";

export default function FindSoulModal({ isOpen, onClose }) {
  const [isSearching, setIsSearching] = useState(false);
  const [isMatching, setIsMatching] = useState(false);
  const [countdown, setCountdown] = useState(60);
  const [myQueueId, setMyQueueId] = useState(null);
  const searchIntervalRef = useRef(null);
  const countdownIntervalRef = useRef(null);
  const hasMatchedRef = useRef(false);
  const queryClient = useQueryClient();
  const navigate = useNavigate();

  const { data: currentUser } = useQuery({
    queryKey: ['currentUser'],
    queryFn: () => base44.auth.me(),
  });

  const { data: existingFriendships } = useQuery({
    queryKey: ['existingFriendships'],
    queryFn: async () => {
      const friendships = await base44.entities.Friendship.list();
      return friendships.filter(f => 
        f.user1_id === currentUser?.id || f.user2_id === currentUser?.id
      );
    },
    initialData: [],
    enabled: !!currentUser,
  });

  // Cleanup function
  const cleanup = async () => {
    if (searchIntervalRef.current) {
      clearInterval(searchIntervalRef.current);
      searchIntervalRef.current = null;
    }
    if (countdownIntervalRef.current) {
      clearInterval(countdownIntervalRef.current);
      countdownIntervalRef.current = null;
    }
    
    if (myQueueId && !hasMatchedRef.current) {
      try {
        await base44.entities.MatchQueue.delete(myQueueId);
      } catch (err) {
        console.log("Cleanup error:", err);
      }
    }
    
    setMyQueueId(null);
    setIsSearching(false);
    setIsMatching(false);
    setCountdown(60);
    hasMatchedRef.current = false;
  };

  // Remove expired entries
  const removeExpiredEntries = async () => {
    try {
      const allEntries = await base44.entities.MatchQueue.list();
      const now = new Date().getTime();
      
      for (const entry of allEntries) {
        const expiresAt = new Date(entry.expires_at).getTime();
        if (expiresAt < now) {
          await base44.entities.MatchQueue.delete(entry.id);
        }
      }
    } catch (error) {
      console.log("Error removing expired entries:", error);
    }
  };

  // Start searching for a match
  const startSearching = async () => {
    try {
      setIsSearching(true);
      setCountdown(60);
      hasMatchedRef.current = false;

      // Remove expired entries first
      await removeExpiredEntries();

      // Remove any existing entries for this user
      const myExisting = await base44.entities.MatchQueue.filter({ user_id: currentUser.id });
      for (const entry of myExisting) {
        await base44.entities.MatchQueue.delete(entry.id);
      }

      // Create queue entry (expires in 2 minutes)
      const expiresAt = new Date();
      expiresAt.setMinutes(expiresAt.getMinutes() + 2);
      
      const queueEntry = await base44.entities.MatchQueue.create({
        user_id: currentUser.id,
        user_name: currentUser.full_name,
        status: "waiting",
        expires_at: expiresAt.toISOString()
      });

      setMyQueueId(queueEntry.id);

      // Start countdown timer
      countdownIntervalRef.current = setInterval(() => {
        setCountdown(prev => {
          if (prev <= 1) {
            handleTimeout();
            return 0;
          }
          return prev - 1;
        });
      }, 1000);

      // Check immediately first
      await checkForMatch();
      
      // Then start checking every 2 seconds
      searchIntervalRef.current = setInterval(() => {
        checkForMatch();
      }, 2000);

    } catch (error) {
      console.error("Error starting search:", error);
      setIsSearching(false);
      alert("Error starting search. Please try again.");
    }
  };

  // Check for available matches
  const checkForMatch = async () => {
    if (hasMatchedRef.current || isMatching) return;
    
    try {
      // Get all waiting queue entries
      const allEntries = await base44.entities.MatchQueue.list();
      const now = new Date().getTime();
      const friendIds = existingFriendships.flatMap(f => [f.user1_id, f.user2_id]);

      // Find valid match candidates
      const validMatches = allEntries.filter(entry => {
        const notExpired = new Date(entry.expires_at).getTime() > now;
        const isWaiting = entry.status === "waiting";
        const notMe = entry.user_id !== currentUser.id;
        const notFriend = !friendIds.includes(entry.user_id);
        const notMatched = !entry.matched_with;
        
        return notExpired && isWaiting && notMe && notFriend && notMatched;
      });

      if (validMatches.length > 0) {
        // Found a match!
        hasMatchedRef.current = true;
        const partner = validMatches[0];
        await createMatchAndNavigate(partner);
      }
    } catch (error) {
      console.error("Error checking for match:", error);
    }
  };

  // Create match and navigate to chat
  const createMatchAndNavigate = async (partner) => {
    if (isMatching) return;
    
    try {
      setIsMatching(true);
      
      // Stop searching immediately
      if (searchIntervalRef.current) {
        clearInterval(searchIntervalRef.current);
        searchIntervalRef.current = null;
      }
      if (countdownIntervalRef.current) {
        clearInterval(countdownIntervalRef.current);
        countdownIntervalRef.current = null;
      }

      // Update partner's queue entry first
      await base44.entities.MatchQueue.update(partner.id, { 
        status: "matched",
        matched_with: currentUser.id
      });
      
      // Update my queue entry
      if (myQueueId) {
        await base44.entities.MatchQueue.update(myQueueId, { 
          status: "matched",
          matched_with: partner.user_id
        });
      }

      // Wait a moment for updates to propagate
      await new Promise(resolve => setTimeout(resolve, 500));

      // Create the match request (8-minute chat)
      const expiresAt = new Date();
      expiresAt.setMinutes(expiresAt.getMinutes() + 8);

      const match = await base44.entities.MatchRequest.create({
        requester_id: currentUser.id,
        requester_name: currentUser.full_name,
        receiver_id: partner.user_id,
        receiver_name: partner.user_name,
        status: "accepted",
        expires_at: expiresAt.toISOString(),
        is_friends: false
      });

      // Wait for match to be fully created
      await new Promise(resolve => setTimeout(resolve, 500));

      // Clean up queue entries
      try {
        if (myQueueId) {
          await base44.entities.MatchQueue.delete(myQueueId);
        }
        await base44.entities.MatchQueue.delete(partner.id);
      } catch (err) {
        console.log("Queue cleanup error:", err);
      }

      // Invalidate and refetch match requests
      await queryClient.invalidateQueries({ queryKey: ['matchRequests'] });
      await queryClient.refetchQueries({ queryKey: ['matchRequests'] });
      
      // Close modal first
      onClose();
      
      // Wait a moment then navigate
      setTimeout(() => {
        navigate(createPageUrl(`MatchChat?matchId=${match.id}`));
      }, 300);

    } catch (error) {
      console.error("Error creating match:", error);
      hasMatchedRef.current = false;
      setIsMatching(false);
      await cleanup();
      alert("Error creating match. Please try again.");
    }
  };

  // Handle timeout
  const handleTimeout = async () => {
    if (hasMatchedRef.current) return;
    await cleanup();
    alert("No users found. Please try again later!");
    onClose();
  };

  // Handle cancel
  const handleCancel = async () => {
    if (hasMatchedRef.current) return;
    await cleanup();
    onClose();
  };

  // Cleanup on unmount
  useEffect(() => {
    return () => {
      if (searchIntervalRef.current) {
        clearInterval(searchIntervalRef.current);
      }
      if (countdownIntervalRef.current) {
        clearInterval(countdownIntervalRef.current);
      }
    };
  }, []);

  // Cleanup when modal closes
  useEffect(() => {
    if (!isOpen && isSearching && !hasMatchedRef.current) {
      cleanup();
    }
  }, [isOpen]);

  return (
    <Dialog open={isOpen} onOpenChange={handleCancel}>
      <DialogContent className="glass-card border-2 border-white/30 max-w-md mx-4 sm:mx-auto">
        <DialogHeader>
          <DialogTitle className="flex items-center gap-2 text-xl sm:text-2xl">
            <Users className="w-5 h-5 sm:w-6 sm:h-6 text-purple-500" />
            Find a Soul
          </DialogTitle>
        </DialogHeader>

        <div className="space-y-4 sm:space-y-6 py-3 sm:py-4">
          {!isSearching && !isMatching ? (
            <div className="text-center space-y-3 sm:space-y-4">
              <div className="w-20 h-20 sm:w-24 sm:h-24 mx-auto rounded-full bg-gradient-to-br from-purple-400 to-pink-400 flex items-center justify-center animate-float">
                <Sparkles className="w-10 h-10 sm:w-12 sm:h-12 text-white" />
              </div>
              <div>
                <h3 className="text-lg sm:text-xl font-semibold text-gray-900 mb-2">
                  Connect with Someone
                </h3>
                <p className="text-sm sm:text-base text-gray-600 px-2">
                  You'll be matched with someone else who's also looking to connect right now for an 8-minute chat.
                </p>
              </div>
              
              <div className="bg-blue-50/50 rounded-2xl p-3 sm:p-4 border border-blue-200/50">
                <p className="text-xs sm:text-sm text-gray-700">
                  <strong className="text-blue-700">How it works:</strong> When you start searching, you'll be matched with the first person who's also searching at the same time.
                </p>
              </div>

              <div className="bg-purple-50/50 rounded-2xl p-3 sm:p-4 border border-purple-200/50">
                <p className="text-xs sm:text-sm text-gray-700">
                  <strong className="text-purple-700">Guidelines:</strong> Be kind, respectful, and authentic. This is a safe space for genuine connection.
                </p>
              </div>

              <Button
                onClick={startSearching}
                className="w-full bg-gradient-to-r from-purple-500 to-pink-500 text-white py-5 sm:py-6 rounded-2xl text-base sm:text-lg font-semibold hover:shadow-lg transition-all"
              >
                <Users className="w-5 h-5 mr-2" />
                Find Someone to Talk To
              </Button>
            </div>
          ) : isMatching ? (
            <div className="text-center space-y-4 sm:space-y-6 py-6 sm:py-8">
              <div className="relative">
                <div className="w-20 h-20 sm:w-24 sm:h-24 mx-auto rounded-full border-4 border-green-500 border-t-transparent animate-spin"></div>
                <div className="absolute inset-0 flex items-center justify-center">
                  <Sparkles className="w-8 h-8 sm:w-10 sm:h-10 text-green-500" />
                </div>
              </div>
              <div>
                <h3 className="text-lg sm:text-xl font-semibold text-gray-900 mb-2">
                  Match Found! 🎉
                </h3>
                <p className="text-sm sm:text-base text-gray-600">
                  Connecting you to the chat...
                </p>
              </div>
            </div>
          ) : (
            <div className="text-center space-y-4 sm:space-y-6 py-6 sm:py-8">
              <div className="relative">
                <div className="w-20 h-20 sm:w-24 sm:h-24 mx-auto rounded-full border-4 border-purple-500 border-t-transparent animate-spin"></div>
                <div className="absolute inset-0 flex items-center justify-center">
                  <Users className="w-8 h-8 sm:w-10 sm:h-10 text-purple-500" />
                </div>
              </div>
              <div>
                <h3 className="text-lg sm:text-xl font-semibold text-gray-900 mb-2">
                  Finding your soul match...
                </h3>
                <p className="text-sm sm:text-base text-gray-600 mb-2">
                  Searching for someone who's also looking to connect
                </p>
                <div className="inline-block bg-purple-100 rounded-full px-4 py-2">
                  <p className="text-sm font-medium text-purple-700">
                    {countdown}s remaining
                  </p>
                </div>
              </div>
              
              <Button
                variant="outline"
                onClick={handleCancel}
                className="rounded-2xl"
              >
                Cancel Search
              </Button>
            </div>
          )}
        </div>
      </DialogContent>
    </Dialog>
  );
}